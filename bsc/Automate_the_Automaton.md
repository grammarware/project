# Automate the Automaton

In the [Chomsky hierarchy](https://youtu.be/_Wq_bt_2pe4) of languages we have a class of regular languages, corresponding to the regular expressions we all know and love (and sometimes [abuse](http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html)), these are parsable with a simple finite state machine which only have states and transitions (and no memory); and right above it a class of context-free languages, for which you need to add a stack or some other memory to such an automaton, and you can describe it with a context-free grammar (and use a tool like [ANTLR](https://www.antlr.org/) or [bison](https://tomassetti.me/why-you-should-not-use-flex-yacc-and-bison/) to generate the parser code out of it).

Grammars are complex and hard to write, so the creators of grammar toolkits, language workbenches and parser generators tend to expose only the most necessary features and assume the rest themselves. On the other hand, regular expressions are naturally simple but often their expressive power is simply not enough. What could be a solution? Writing a parsing algorithm yourself, of course! A parsing automaton is a simple implementation of a deeply nested `if`/`switch` construct with at least one variable (e.g., `state`) guiding the process together with the input that is being consumed.

The goal of this project is to write a generator for such automata. The syntax of the input for this generator is negotiable and will be designed as a part of this project. The choice of the implementation language is up for the student. If there is time left in the project, your generator can be compared (feature-wise or experimentally) with some existing parser generator for a comparable language class (e.g., [**owl**](https://github.com/ianh/owl)).

Get in touch with your [potential future supervisor](mailto:v.zaytsev@utwente.nl) to discuss details!
